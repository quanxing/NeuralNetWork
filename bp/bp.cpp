
#include "stdafx.h"

#define R 30
#define S1 30//第一层神经元个数
#define S2 1
#define index 0
#define size 26
struct Layer1{
	double w1[S1][R];// 权值矩阵
	double b1[S1];// 偏置
	double a1[S1];// 层输出
	double n1[S1];// 层净输出
	double Se1[S1];//敏感性

};
struct Layer2{
	double w2[S2][S1];
	double b2[S2];
	double a2[S2];
	double n2[S2];
	double Se2[S2];//敏感性
};
struct TestAss{
	int p[R];//输入向量 字母模式
	double t;//目标向量
}/*test[]={
	{{1},(double)(2+sqrt(2.0))/2.0},
	//{{5},(double)(2-sqrt(2.0))/2.0}
};*/
test[]={               // 结构体中存放26的大写字母的样本图像
	{{-1,-1,1,-1,-1, -1,1,-1,1,-1, 1,-1,-1,-1,1, 1,1,1,1,1,  1,-1,-1,-1,1, 1,-1,-1,-1,1},  1},               // A
{{1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,-1},  2},  //B
{{  -1, 1, 1, 1, -1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1,
	-1, 1, 1, 1, -1 },3}, //C
{{	1, 1, 1, -1, -1,
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1,
	1, 1, 1, -1, -1},4},           // D
{{	1, 1, 1, 1, 1,
	1, -1, -1, -1, -1,
	1, 1, 1, 1, 1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1,
	1, 1, 1, 1, 1 },5}, //E
{{
	 1, 1, 1, 1, 1,
	1, -1, -1, -1, -1,
	1, 1, 1, 1, 1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1,
	1, -1, -1, -1, -1},6}, //F
{{1, 1, 1, 1, -1,
	1, -1, -1, -1, -1,
	1, -1, 1, 1, 1,
	1, -1, -1, 1, -1,
	1, -1, -1, 1, -1,
	1, 1, 1, 1, -1},7},//G
{{
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1,
	1, 1, 1, 1, 1,
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1,
	1, -1, -1, -1, 1},8},//H
{{
	-1, 1, 1, 1, -1,
	-1, -1, 1, -1, -1,
	-1, -1, 1, -1, -1,
	-1, -1, 1, -1, -1,
	-1, -1, 1, -1, -1,
	-1, 1, 1, 1, -1},9},//I
{{		 
	-1, 1, 1, 1, -1,
	-1, -1, 1, -1, -1,
	-1, -1, 1, -1, -1,
	1, -1, 1, -1, -1,
	1, -1, 1, -1, -1,
	1, 1, 1, -1, -1},10},//J
{{		 
	-1, 1, -1, -1, 1,
	-1, 1, -1, 1, -1,
	-1, 1, 1, -1, -1,
	-1, 1, 1, -1, -1,
	-1, 1, -1, 1,-1,
	-1, 1, -1, -1, 1},11},//K
{{		 
	-1, 1, -1, -1, -1,
	-1, 1, -1, -1, -1,
	-1, 1, -1, -1, -1,
	-1, 1, -1, -1, -1,
	-1, 1, -1, -1,-1,
	-1, 1, 1, 1, 1},12},//L
{{		 
	-1, -1, -1, -1,  -1 ,
	-1,  1, -1,  1,  -1,
	 1,  -1, 1,  -1,  1,
	 1,  -1, -1, -1,  1,
	 -1,  -1, -1, -1, -1,
	-1, -1,  -1, -1, -1},13},//M
{{		 
	1, -1, -1, -1,  1 ,
	1,  -1, -1,  -1,  1,
    1,  -1, 1,  -1, 1,
	1,  -1, -1,  1, 1,
	1,  -1, -1, -1, 1,
	1, -1,  -1, -1, -1},14},//N
{{
	-1,1,1,1,-1,
    1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	-1,1,1,1,-1},15},//O
{{
	1,1,1,-1,-1,
    1,-1,-1,1,-1,
	1,-1,-1,1,-1,
	1,1,1,-1,-1,
	1,-1,-1,-1,-1,
	1,-1,-1,-1,-1},16},//P
{{
	-1,1,1,1,-1,
    1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	1,-1,1,-1, 1,
	-1,1,1,1,-1,
	-1,-1,-1,-1,1},17},//Q
{{
	1,1,1,1,-1,
    1,-1,-1,1,-1,
	1,1,1,-1,-1,
	1,-1,1,-1, -1,
	1,-1,-1,1,-1,
	1,-1,-1,-1,1},18},//R
{{
	-1,1,1,1,-1,
    1,-1,-1,-1,-1,
	-1,-1,1,-1,-1,
	-1,-1,-1,1, -1,
	1,-1,-1,-1,1,
	-1,1,1,1,-1},19},//S
{{
	1,1,1,1,1,
    -1,-1,1,-1,-1,
	-1,-1,1,-1,-1,
	-1,-1,1,-1, -1,
	-1,-1,1,-1,-1,
	-1,-1,1,-1,-1},20},//T
{{
	1,-1,-1,-1,1,
    1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	1,-1,-1,-1,1,
	-1,1,1,1,-1},21},//U
{{
	1,-1,-1,-1,1,
    1,-1,-1,-1,1,
    1,-1,-1,-1,1,
	-1,1,-1,1,-1,
	-1,-1,1,-1,-1,
	-1,-1,-1,-1,-1},22},//V
{{
  1,-1,-1,-1,1,
   1,-1,1,-1,1,
   -1,1,-1,1,-1,
   -1,1,-1,1,-1,
   -1,-1,-1,-1,-1,
   -1,-1,-1,-1,-1},23},//W
   {{
   1,-1,-1,-1,1,
   -1,1,-1,1,-1,
   -1,-1,1,-1,-1,
   -1,1,-1,1,-1,
   1,-1,-1,-1,1,
   -1,-1,-1,-1,-1},24},//X
{{
  1,-1,-1,-1,1,
  -1,1,-1,1,-1,
   -1,-1,1,-1,-1,
   -1,-1,1,-1,-1,
   -1,-1,1,-1,-1,
   -1,-1,1,-1,-1},25},//Y
{{
  1,1,1,1,1,
  -1,-1,-1,1,-1,
   -1,-1,-1,1,-1,
   -1,-1,1,-1,-1,
   -1,1,-1,-1,-1,
   1,1,1,1,1},26}//Z
};
void clearLayer(Layer1 *l1,Layer2 *l2){
	int i,j;
	//L1
	for(i=0;i<S1;i++){
		l1->a1[i]=0;
		l1->n1[i]=0;
		l1->Se1[i]=0;
	}


	// L2
	for(i=0;i<S2;i++){
		l2->a2[i] = 0;
		l2->n2[i]= 0;
		l2->Se2[i] = 0;
	}
}
void learnBP(TestAss test[],Layer1 *l1,Layer2 *l2){

	void logsig(double n[],double a[S1],double F[S1][S1]);
	double purelin(double n[S2],double a[S2]);
	double getError(TestAss *t,Layer1 *l1,Layer2 *l2);


	int i,j;
	double e = 0;// 单个误差
	double err = 0;
	int count = 0;// 统计循环次数
	double F1[S1][S1]={0}; //递推矩阵
	struct TestAss *t;
	//double rate=0.02;//学习速率
	double rate;
	printf("请输入学习步长：\n");
	scanf("%lf",&rate);
	
	printf("输入循环总次数:\n");
	int N;
	scanf("%d",&N);

	double Error;
	printf("误差：\n");
	scanf("%lf",&Error);
	

	while(count<N){ // 进行轮循环 -26个字母走一遍算一次
		for(t=test+index;t<test+size+index;t++){    //逐个训练26 个样本点
			clearLayer(l1,l2);// 重新置零
			//count1 = 0;//统计每个字母的达到精度的次数
			//while(count1<100000){
				//L1层 净输入n1
				for(i=0;i<S1;i++){
					for(j=0;j<R;j++){
						l1->n1[i] += l1->w1[i][j] * (t)->p[j];	
 					}
					//加上偏置	
					l1->n1[i] += l1->b1[i];
				}
				//1 层输出a1,同时输出L1层的倒数矩阵
				logsig(l1->n1,l1->a1,F1);
				// L2 净输入
				for(i=0;i<S2;i++){
					for(j=0;j<S1;j++){			
						l2->n2[i] += l2->w2[i][j] * l1->a1[j]; // 第一层的输出为第二层的输入		
					}
					//加上偏置	
					l2->n2[i] += l2->b2[i];

					l2->a2[i]  = l2->n2[i];// 净输入= 输出
				}
				
				e =(t)->t - l2->a2[0];   // error,  对于每个字母的误差1*1
				 
				//if( e*e <=0.001){        //  e*e 每个字母达到精度要求了
				//	//printf("%lf\n",sqrt(e*e));
				//	break;// 接着进行第二个// for
				//}

				// 反向传播简单设计，因为是最后一层 1*1
				//else{
					l2->Se2[S2-1] = -2 * e;
					for(i=0;i<S1;i++){
						for(j=0;j<S1;j++){
							l1->Se1[i] += F1[i][j] * l2->w2[S2-1][j]; 
						}
						l1->Se1[i] *= l2->Se2[S2-1];
					}
					
					//调权值W2,b2;
					for(i=0;i<S2;i++){ //1
						for(j=0;j<S1;j++){//2
							l2->w2[i][j] -= rate * l2->Se2[S2-1] * l1->a1[j];
						}
					}
					l2->b2[S2-1] -= rate * l2->Se2[S2-1];//ok

					// 调权值W1,b1;
					for(i=0;i<S1;i++){
						for(j=0;j<R;j++){
							l1->w1[i][j] -= l1->Se1[i] * (t)->p[j] * rate;						
						}
						l1->b1[i] -= rate * l1->Se1[i];
					}
				//}//else			
				//count1++;
				//num += count1;// num统计总的次数
				clearLayer(l1,l2);
			//}//while
		
		}//for 一轮循环结束
		err = 0;
		for(i=index;i<size+index;i++){// 一轮结束后开始计算开始计算调权后的值是否能使所有的字母都达到精度
			err = getError(test+i,l1,l2);
			//printf("\n%10.4f,%d\n",err*err,i);
			if(err * err >Error){
				break;
			}
		}
		//getchar();
		if(i>=size)
		{
			printf("\n学习了%d个字母,总共循环次数为：%d\n",i,count*26);
			break;
		}
		count++; 
	}
}

double getError(TestAss *t,Layer1 *l1,Layer2 *l2){
	int i,j;
	void logsig1(double n[],double a[S1]);
		clearLayer(l1,l2);
		for(i=0;i<S1;i++){
			for(j=0;j<R;j++){
				l1->n1[i] += l1->w1[i][j] * (t)->p[j];	
 			}
			//加上偏置	
			l1->n1[i] += l1->b1[i];
		}
		//1 层输出a1
		logsig1(l1->n1,l1->a1);
		for(i=0;i<S2;i++){
			for(j=0;j<S1;j++){			
				l2->n2[i] += l2->w2[i][j] * l1->a1[j]; // 第一层的输出为第二层的输入		
			}
			//加上偏置	
			l2->n2[i] += l2->b2[i];

			l2->a2[i]  = l2->n2[i];// 净输入= 输出
		}
		return t->t - l2->a2[0];
}
void show(TestAss *t){
	int i;
	for(i=0;i<R;i++){
		if(t->p[i] == -1)
			printf(" ");
		else
			printf("*");
		if(i%5 ==4)
			printf("\n");
	}
}
double testBP(TestAss test[],Layer1 *l1,Layer2 *l2){
	TestAss *t;
	t= test;
	printf("当前字母图像为：\n");
	show(t);
	printf("字母对应的数字为：\n");
	double error = getError(t,l1,l2);// error >0 or <0,then
	if(error>0)
		return t->t - error;
	else
		return t->t + error;
}
void logsig1(double n[],double a[S1]){
	int i;
	for(i=0;i<S1;i++){
		a[i] = (double)1/(1+exp(-n[i])); //e 的n 次方
	}
}
void logsig(double n[],double a[S1],double F[S1][S1]){// n 代表净输入,a 表示某层网络的输出.第一层会用到
	int i;
	for(i=0;i<S1;i++){
		a[i] = (double)1/(1+exp(-n[i])); //e 的n 次方
		F[i][i] = ((double)1 - a[i]) * a[i];
	}

}

void purelin(double n[],double a[S2]){//第二层会用到,线性函数
	for(int i=0;i<S2;i++){
		a[i] = n[i];// 
	}
}
int Deriv_purelin(){
	return 1;
}

void InitLayer(Layer1 *l1,Layer2 *l2){
	int i,j,sign=1;
	
	srand(10);// 初始化seed
	//L1 
	for(i=0;i<S1;i++){
		
		for(j=0;j<R;j++){
			if(rand()%2)// 偶数为负数
				sign =-sign;
			l1->w1[i][j] =rand()/(RAND_MAX+0.0) * sign;//Random();//rand()%2; 产生0-1的小数
		}
		l1->b1[i] =rand()/(RAND_MAX+0.0) * sign;//Random();//rand()%2;

		l1->a1[i]=0;
		l1->n1[i]=0;
		l1->Se1[i]=0;
	}
	

	// L2
	for(i=0;i<S2;i++){
		
		for(j=0;j<S1;j++){
			if(rand()%2)// 偶数为负数
				sign =-sign;
			l2->w2[i][j] =rand()/(RAND_MAX+0.0);//Random();
		}
		l2->b2[i] = rand()/(RAND_MAX+0.0);//Random();//rand()%2;
		l2->a2[i] = 0;
		l2->n2[i]= 0;
		l2->Se2[i] = 0;
	}

}


void  main(){


	Layer1 layer1={       // 第一层初始化权值矩阵
		{{0},{0}},{{0},{0}},{0},{0}
	};
	Layer2 layer2={              //第二层初始化权值矩阵
		{0},{0},{0},{0}	
	};
	InitLayer(&layer1,&layer2);// 产生随机值 给 不同层赋值 access
	Layer1 *l1 =&layer1;
	Layer2 *l2 =&layer2;
	learnBP(test,&layer1,&layer2);
	int i;
	for(i=0;i<size;i++){
		printf("\n%lf ",testBP(test+i,&layer1,&layer2));
		system("pause");
	}

}


